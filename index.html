<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="mobile-web-app-capable" content="yes" />
<meta name="theme-color" content="#0b0f1a" />
<title>Cosmo Arcade ‚Äî Touch Update</title>
<style>
  :root { --bg:#0b0f1a; --panel:#0f1628; --line:#1f2844; --btn:#1b2a4a; --btn-b:#33538d; }
  html,body{margin:0;height:100%;background:var(--bg);color:#fff;font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial}
  #wrap{display:flex;flex-direction:column;height:100dvh}
  header{padding:8px 12px;background:var(--panel);border-bottom:1px solid var(--line);display:flex;align-items:center;gap:8px}
  header h1{font-size:16px;margin:0;opacity:.9}
  #ui{margin-left:auto;display:flex;gap:6px;align-items:center}
  #score{padding:6px 10px;background:#141e34;border:1px solid #263556;border-radius:8px;font-weight:700}
  #boosts{opacity:.9;font-size:12px;max-width:40ch;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  #stage{position:relative;flex:1;min-height:0}
  #canvas{position:absolute;inset:0;display:block;width:100%;height:100%;touch-action:none}
  #menu{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(5,8,14,.85)}
  .card{background:#111a2e;border:1px solid #263556;border-radius:14px;padding:18px;max-width:520px;width:92%;box-shadow:0 8px 24px rgba(0,0,0,.4)}
  .card h2{margin:0 0 10px 0}
  .btn{display:block;width:100%;padding:14px 16px;margin:8px 0;background:var(--btn);border:1px solid var(--btn-b);border-radius:12px;color:#fff;font-weight:700;text-align:center;text-decoration:none;cursor:pointer}
  .row{display:flex;gap:8px}
  .btn.small{flex:1;padding:10px}
  .field{display:flex;gap:8px;align-items:center;margin-top:8px}
  .field label{opacity:.8;font-size:13px}
  select{background:#0e1628;color:#fff;border:1px solid #2b3e68;border-radius:8px;padding:8px}

  /* –î–∂–æ–π—Å—Ç–∏–∫–∏ */
  #touch{position:absolute;left:10px;right:10px;bottom:10px;display:flex;justify-content:space-between;gap:10px;pointer-events:none}
  .joy{pointer-events:auto;position:relative;width:120px;height:120px;border-radius:50%;background:#0e1628cc;border:1px solid #2b3e68}
  .knob{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:56px;height:56px;border-radius:50%;background:#142348;border:1px solid #3b5ca0}
  .joy.small{width:100px;height:100px}
  .joy.small .knob{width:48px;height:48px}

  /* –ü–æ–¥—Å–∫–∞–∑–∫–∞ */
  #hint{position:absolute;right:10px;bottom:10px;background:#0e1628cc;border:1px solid #2b3e68;border-radius:10px;padding:8px 10px;font-size:12px}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <h1>Cosmo Arcade</h1>
    <div id="ui">
      <div id="score">0</div>
      <div id="boosts"></div>
      <button id="back" class="btn small" style="width:auto;padding:6px 10px;margin:0 0 0 8px">–í –º–µ–Ω—é</button>
    </div>
  </header>

  <div id="stage">
    <canvas id="canvas"></canvas>

    <!-- –ú–µ–Ω—é -->
    <div id="menu">
      <div class="card">
        <h2>–í—ã–±–µ—Ä–∏ —Ä–µ–∂–∏–º</h2>
        <button class="btn" data-mode="worm">üêç Worm Arena</button>
        <div class="field">
          <label for="wormColor">–¶–≤–µ—Ç —á–µ—Ä–≤—è—á–∫–∞:</label>
          <select id="wormColor">
            <option value="rainbow">üåà –†–∞–¥—É–∂–Ω—ã–π</option>
            <option value="red">üî¥ –ö—Ä–∞—Å–Ω—ã–π</option>
            <option value="green">üü¢ –ó–µ–ª—ë–Ω—ã–π</option>
            <option value="blue">üîµ –°–∏–Ω–∏–π</option>
            <option value="purple">üü£ –§–∏–æ–ª–µ—Ç–æ–≤—ã–π</option>
          </select>
        </div>
        <button class="btn" data-mode="cat" style="margin-top:6px">üê± Trampoline Cat</button>
        <div class="row" style="margin-top:6px">
          <div class="btn small" id="help">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</div>
        </div>
        <p style="opacity:.8;font-size:12px;margin:8px 0 0 0">
          –û–±–Ω–æ–≤–ª–µ–Ω–∏—è: üåà —Ä–∞–¥—É–∂–Ω—ã–π —á–µ—Ä–≤—å + –≤—ã–±–æ—Ä —Ü–≤–µ—Ç–∞, –ª–µ–≤—ã–π –¥–∂–æ–π—Å—Ç–∏–∫ –¥–ª—è –ø–æ–≤–æ—Ä–æ—Ç–∞; —É –∫–æ—Ç–∞ ‚Äî —Ç–∞–ø = –ø—Ä—ã–∂–æ–∫, –ø—Ä–∞–≤—ã–π –º–∏–Ω–∏-–¥–∂–æ–π—Å—Ç–∏–∫ –¥–ª—è —Ö–æ–¥—å–±—ã.
        </p>
      </div>
    </div>

    <!-- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: –ª–µ–≤—ã–π –¥–∂–æ–π—Å—Ç–∏–∫ (–ø–æ–≤–æ—Ä–æ—Ç), –ø—Ä–∞–≤—ã–π –º–∏–Ω–∏-–¥–∂–æ–π—Å—Ç–∏–∫ (—Ö–æ–¥—å–±–∞) -->
    <div id="touch">
      <div class="joy" id="joyLeft"><div class="knob"></div></div>
      <div class="joy small" id="joyRight"><div class="knob"></div></div>
    </div>

    <div id="hint"></div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
  const menu = document.getElementById('menu');
  const scoreEl = document.getElementById('score');
  const boostsEl = document.getElementById('boosts');
  const backBtn = document.getElementById('back');
  const hint = document.getElementById('hint');
  const selWormColor = document.getElementById('wormColor');

  // –ë–ª–æ–∫–∏—Ä—É–µ–º —Å–∫—Ä–æ–ª–ª/–∑—É–º –Ω–∞–¥ –∏–≥—Ä–æ–π
  ['touchstart','touchmove','gesturestart'].forEach(evt=>{
    document.addEventListener(evt, e => {
      if (e.target.closest('#canvas') || e.target.closest('.joy')) e.preventDefault();
    }, { passive: false });
  });

  function resize() {
    const r = Math.max(1, Math.min(window.devicePixelRatio || 1, 3));
    const w = canvas.clientWidth = canvas.parentElement.clientWidth;
    const h = canvas.clientHeight = canvas.parentElement.clientHeight;
    canvas.width = Math.floor(w * r);
    canvas.height = Math.floor(h * r);
    ctx.setTransform(r, 0, 0, r, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  // HUD/–±—É—Å—Ç—ã
  let score = 0;
  const boosts = {};
  const hasBoost = k => (boosts[k]||0) > 0;
  const addBoost = (k, secs) => { boosts[k]=(boosts[k]||0)+secs; updateHud(); };
  const scoreMul = () => hasBoost('x2') ? 2 : 1;
  function updateHud(){
    scoreEl.textContent = Math.round(score);
    const list = Object.entries(boosts).map(([k,v])=> `${k}:${v.toFixed(0)}s`).join('  ');
    boostsEl.textContent = list;
  }
  function tickBoosts(dt){
    let changed=false;
    for(const k in boosts){ boosts[k]-=dt; if(boosts[k]<=0){ delete boosts[k]; changed=true; } }
    if (changed) updateHud();
  }
  function resetHud(){ score=0; for (const k in boosts) delete boosts[k]; updateHud(); }

  // –°–æ—Å—Ç–æ—è–Ω–∏–µ
  let state = 'menu';
  function showMenu(){ state='menu'; menu.style.display='flex'; }
  function hideMenu(){ menu.style.display='none'; }
  document.querySelectorAll('[data-mode]').forEach(btn=>{
    btn.onclick = () => {
      if (btn.dataset.mode === 'worm'){ startWorm(); state='worm'; }
      else { startCat(); state='cat'; }
      hideMenu();
    };
  });
  backBtn.onclick = showMenu;
  document.getElementById('help').onclick = () => {
    hint.textContent = '–ß–µ—Ä–≤—å: –ª–µ–≤—ã–π –¥–∂–æ–π—Å—Ç–∏–∫ –∫—Ä—É—Ç–∏—Ç –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ. –ö–æ—Ç: —Ç–∞–ø = –ø—Ä—ã–∂–æ–∫, –ø—Ä–∞–≤—ã–π –¥–∂–æ–π—Å—Ç–∏–∫ ‚Äî —Ö–æ–¥—å–±–∞.';
    setTimeout(()=> hint.textContent='', 4000);
  };

  // ========= –î–∂–æ–π—Å—Ç–∏–∫–∏ =========
  function makeJoystick(root, radiusPx=50){
    const knob = root.querySelector('.knob');
    const state = {ax:0, ay:0, active:false};
    let rect=null, id=null;

    function setKnob(dx,dy){
      const len = Math.hypot(dx,dy);
      const max = radiusPx;
      const k = len>max ? max/len : 1;
      knob.style.transform = `translate(${dx*k}px, ${dy*k}px)`;
    }
    function reset(){
      state.ax=0; state.ay=0; state.active=false; knob.style.transform='translate(-50%,-50%)';
    }

    root.addEventListener('pointerdown', e=>{
      id = e.pointerId; rect = root.getBoundingClientRect(); root.setPointerCapture?.(id);
      state.active=true;
      const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2;
      const dx = e.clientX - cx, dy = e.clientY - cy;
      const nx = dx/radiusPx, ny = dy/radiusPx;
      state.ax = Math.max(-1, Math.min(1, nx));
      state.ay = Math.max(-1, Math.min(1, ny));
      setKnob(state.ax*radiusPx, state.ay*radiusPx);
    });
    root.addEventListener('pointermove', e=>{
      if (!state.active || e.pointerId!==id) return;
      const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2;
      const dx = e.clientX - cx, dy = e.clientY - cy;
      const nx = dx/radiusPx, ny = dy/radiusPx;
      state.ax = Math.max(-1, Math.min(1, nx));
      state.ay = Math.max(-1, Math.min(1, ny));
      setKnob(state.ax*radiusPx, state.ay*radiusPx);
    });
    const end = e=>{ if (e.pointerId===id){ reset(); } };
    root.addEventListener('pointerup', end);
    root.addEventListener('pointercancel', end);
    root.addEventListener('pointerleave', end);

    return state;
  }

  const joyLeft = makeJoystick(document.getElementById('joyLeft'), 50);   // –ø–æ–≤–æ—Ä–æ—Ç/–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
  const joyRight = makeJoystick(document.getElementById('joyRight'), 40); // —Ö–æ–¥—å–±–∞ (–≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å)

  // ========= Worm Arena =========
  let worm, foods=[], stars=[];
  let wormColorMode = 'rainbow';
  selWormColor.addEventListener('change', ()=> wormColorMode = selWormColor.value);

  function startWorm(){
    resetHud();
    wormColorMode = selWormColor.value;
    const W = canvas.clientWidth, H = canvas.clientHeight;
    worm = { x:W/2, y:H/2, angle:-Math.PI/2, speed: Math.min(W,H)*0.18, turn: 2.6, trail:[], segments:14, step:4 };
    foods = []; stars = [];
    const foodCount = Math.round((W*H)/9000);
    for(let i=0;i<foodCount;i++) foods.push({x:Math.random()*W, y:Math.random()*H});
    for(let i=0;i<4;i++) stars.push({x:Math.random()*W, y:Math.random()*H, type:['speed','magnet','x2','shield'][i%4]});
  }

  function updateWorm(dt){
    // —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: –ª–µ–≤—ã–π –¥–∂–æ–π—Å—Ç–∏–∫ –∑–∞–¥–∞—ë—Ç —É–≥–æ–ª (–ø–æ –≤–µ–∫—Ç–æ—Ä—É)
    if (joyLeft.active){
      // atan2(ay, ax) ‚Äî –Ω–æ —É –Ω–∞—Å –æ—Å—å Y –≤–Ω–∏–∑, –∏–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º:
      worm.angle = Math.atan2(joyLeft.ay, joyLeft.ax);
    }
    // –¥–≤–∏–∂–µ–Ω–∏–µ –≤–ø–µ—Ä—ë–¥ –ø–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—é
    const spd = worm.speed * (hasBoost('speed')?1.5:1);
    worm.x += Math.cos(worm.angle)*spd*dt;
    worm.y += Math.sin(worm.angle)*spd*dt;

    const W = canvas.clientWidth, H = canvas.clientHeight;
    if (worm.x<0) worm.x+=W; if (worm.x>W) worm.x-=W;
    if (worm.y<0) worm.y+=H; if (worm.y>H) worm.y-=H;

    worm.trail.unshift({x:worm.x,y:worm.y});
    if (worm.trail.length > 1400) worm.trail.pop();

    if (hasBoost('magnet')){
      for (const f of foods){
        const dx = worm.x - f.x, dy = worm.y - f.y, d = Math.hypot(dx,dy);
        if (d < 140){ f.x += dx/d * 100*dt; f.y += dy/d * 100*dt; }
      }
    }
    for (let i=foods.length-1;i>=0;i--){
      const f = foods[i];
      if (Math.hypot(f.x-worm.x, f.y-worm.y) < 12){
        foods.splice(i,1);
        score += 5 * scoreMul(); updateHud();
        worm.segments = Math.min(90, worm.segments+1);
        foods.push({x:Math.random()*W, y:Math.random()*H});
      }
    }
    for (let i=stars.length-1;i>=0;i--){
      const b = stars[i];
      if (Math.hypot(b.x-worm.x, b.y-worm.y) < 16){
        stars.splice(i,1);
        addBoost(b.type==='x2'?'x2':b.type, 8);
        setTimeout(()=> stars.push({x:Math.random()*W, y:Math.random()*H, type:['speed','magnet','x2','shield'][Math.floor(Math.random()*4)]}), 1500);
      }
    }
  }

  // –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è HSL ‚Üí RGB
  function hsl(h,s,l){
    s/=100; l/=100;
    const k = n => (n + h/30) % 12;
    const a = s * Math.min(l,1-l);
    const f = n => l - a * Math.max(-1, Math.min(k(n)-3, Math.min(9-k(n),1)));
    return `rgb(${Math.round(255*f(0))},${Math.round(255*f(8))},${Math.round(255*f(4))})`;
  }

  function drawWorm(){
    const W = canvas.clientWidth, H = canvas.clientHeight;
    ctx.fillStyle = '#0a0e19'; ctx.fillRect(0,0,W,H);
    // —Ñ–æ–Ω-–∑–≤—ë–∑–¥—ã
    ctx.save(); ctx.globalAlpha=.6;
    for(let i=0;i<120;i++){ const x=(i*97)%W; const y=(i*53)%H; ctx.fillStyle=i%7===0?'#7dd3ff':'#cbd5e1'; ctx.fillRect(x,y,2,2); }
    ctx.restore();
    // –µ–¥–∞ / –±—É—Å—Ç—ã
    ctx.fillStyle='#63c8ff';
    foods.forEach(f=>{ ctx.beginPath(); ctx.arc(f.x,f.y,3.5,0,Math.PI*2); ctx.fill(); });
    stars.forEach(b=> drawStar(b.x,b.y,9,b.type));
    // —Ç–µ–ª–æ
    for(let s=0;s<worm.segments;s++){
      const idx = s*worm.step; const p = worm.trail[idx] || worm;
      const r = Math.max(3, 9 - s*0.08);
      let color = '#f9a825'; // default
      if (wormColorMode==='rainbow'){
        const hue = (s*12 + (performance.now()/40)%360) % 360;
        color = hsl(hue, 90, 55);
      } else if (wormColorMode==='red') color='#ff5b5b';
      else if (wormColorMode==='green') color='#7eed6b';
      else if (wormColorMode==='blue') color='#64b5ff';
      else if (wormColorMode==='purple') color='#c084fc';
      // –≥–æ–ª–æ–≤–Ω–æ–π —Å–µ–≥–º–µ–Ω—Ç —á—É—Ç—å —è—Ä—á–µ
      if (s===0 && wormColorMode!=='rainbow') color = '#ffd166';
      ctx.beginPath(); ctx.fillStyle = color;
      ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill();
    }
  }

  // ========= Trampoline Cat =========
  let cat, tramps=[], camY=0, maxY=0, catStars=[], jumpLatch=false;

  function startCat(){
    resetHud();
    const W = canvas.clientWidth;
    cat = { x:W/2, y:200, vx:0, vy:0, onGround:false };
    tramps = []; catStars = []; camY=0; maxY=0; jumpLatch=false;
    for(let i=0;i<14;i++) addTramp(i===0 ? 230 : null);
    for(let i=0;i<3;i++) spawnCatBoost(Math.random()*600+200);
  }
  function addTramp(constY=null){
    const W = canvas.clientWidth;
    const gapY = 90 + Math.random()*90;
    const newY = constY!==null ? constY : (tramps.length ? tramps[tramps.length-1].y - gapY : 230);
    const x = 60 + Math.random()*(W-120);
    tramps.push({x, y:newY, w:Math.max(100, Math.min(180, W*0.25)), h:16, bouncy: 13+Math.random()*4});
  }
  function spawnCatBoost(y){
    const W = canvas.clientWidth;
    catStars.push({x: 60+Math.random()*(W-120), y: y-(Math.random()*200), r:10, type: ['speed','magnet','x2'][Math.floor(Math.random()*3)]});
  }

  // –¢–∞–ø –ø–æ –∫–∞–Ω–≤–∞—Å—É = –ø–æ–ø—ã—Ç–∫–∞ –ø—Ä—ã–∂–∫–∞ (–µ—Å–ª–∏ –Ω–µ –ø–æ –¥–∂–æ–π—Å—Ç–∏–∫—É)
  canvas.addEventListener('pointerdown', (e)=>{
    if (e.target.closest('.joy')) return;
    // –∫–æ—Ä–æ—Ç–∫–∏–π –∏–º–ø—É–ª—å—Å jump
    catJumpTapTimer = 0.12; // —Å–µ–∫—É–Ω–¥—ã
  });

  let catJumpTapTimer = 0;

  function updateCat(dt){
    const W = canvas.clientWidth, H = canvas.clientHeight;

    // —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å –æ—Ç –ø—Ä–∞–≤–æ–≥–æ –¥–∂–æ–π—Å—Ç–∏–∫–∞
    const move = joyRight.ax; // -1..1
    const moveSpeed = hasBoost('speed') ? 240 : 180;
    cat.vx = move * moveSpeed;

    // —Ñ–∏–∑–∏–∫–∞
    cat.vy += 520*dt;
    cat.x += cat.vx*dt;
    cat.y += cat.vy*dt;
    cat.x = Math.max(16, Math.min(W-16, cat.x));

    // –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
    cat.onGround = false;
    for (const t of tramps){
      if (cat.vy > 0 && cat.y+8 >= t.y && cat.y+8 <= t.y+t.h && cat.x > t.x && cat.x < t.x+t.w){
        cat.y = t.y-8; cat.vy = -t.bouncy; cat.onGround = true; score += 1*scoreMul(); updateHud();
      }
    }

    // –ø—Ä—ã–∂–æ–∫: —Ç–∞–ø –ø–æ —ç–∫—Ä–∞–Ω—É –∏–ª–∏ Space (—Å latch, —á—Ç–æ–±—ã –Ω–µ –∑–∞–ª–∏–ø–∞–ª–æ)
    if (catJumpTapTimer > 0) catJumpTapTimer -= dt;
    const wantTapJump = catJumpTapTimer > 0;
    const wantSpaceJump = false; // –º–æ–∂–Ω–æ –≤–∫–ª—é—á–∏—Ç—å –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –ø—Ä–∏ –∂–µ–ª–∞–Ω–∏–∏
    const wantJump = wantTapJump || wantSpaceJump;

    if (wantJump && cat.onGround && !jumpLatch){
      jumpLatch = true;
      cat.vy = -(hasBoost('speed') ? 18 : 14);
      catJumpTapTimer = 0;
    }
    if (!wantJump) jumpLatch = false;

    // –∫–∞–º–µ—Ä–∞
    if (cat.y < maxY) maxY = cat.y;
    camY = Math.min(0, -maxY + H*0.28);

    // —Å–ø–∞–≤–Ω/—Ä–µ—Ü–∏–∫–ª–∏–Ω–≥
    const highest = tramps.reduce((m,t)=> Math.min(m,t.y), tramps[0]?.y||0);
    while (highest - camY > -H*1.2 && tramps.length < 36) addTramp();
    for (let i=tramps.length-1;i>=0;i--){
      if (tramps[i].y - camY > H+100){
        tramps.splice(i,1);
        addTramp(tramps.reduce((m,t)=>Math.min(m,t.y),9999) - (90+Math.random()*90));
        spawnCatBoost(tramps.reduce((m,t)=>Math.min(m,t.y),9999) - 100);
      }
    }

    // –±—É—Å—Ç—ã
    for (let i=catStars.length-1;i>=0;i--){
      const b = catStars[i];
      let dx = b.x - cat.x, dy = (b.y - camY) - cat.y;
      if (hasBoost('magnet')){
        const d = Math.hypot(dx,dy); if (d < 160){ b.x -= dx/d * 140*dt; b.y -= dy/d * 140*dt; }
      }
      if (Math.hypot(dx,dy) < 16){ catStars.splice(i,1); addBoost(b.type, 8); }
    }

    if (cat.y - camY > H + 80){ showMenu(); }
  }

  function drawCat(){
    const W = canvas.clientWidth, H = canvas.clientHeight;
    ctx.fillStyle='#0a0e19'; ctx.fillRect(0,0,W,H);
    ctx.save(); ctx.globalAlpha=.6;
    for(let i=0;i<120;i++){ const x=(i*97)%W; const y=((i*53)%H) + (camY*.2 % H); ctx.fillStyle=i%7===0?'#7dd3ff':'#cbd5e1'; ctx.fillRect(x,y,2,2); }
    ctx.restore();
    catStars.forEach(b => drawStar(b.x, b.y - camY, 10, b.type));
    ctx.fillStyle='#7cf0d0'; ctx.strokeStyle='rgba(0,0,0,.22)';
    tramps.forEach(t=>{ roundRect(t.x, t.y - camY, t.w, t.h, 8); ctx.fill(); ctx.stroke(); });
    drawCatAstronaut(cat.x, cat.y - camY);
  }

  // ========= –†–µ–Ω–¥–µ—Ä-—É—Ç–∏–ª–∏—Ç—ã =========
  function drawStar(x,y,r,type){
    ctx.save(); ctx.translate(x,y); ctx.rotate(performance.now()/800);
    ctx.beginPath();
    for(let i=0;i<10;i++){ const ang=i*Math.PI/5; const rr=(i%2===0? r : r*0.45); ctx.lineTo(Math.cos(ang)*rr, Math.sin(ang)*rr); }
    ctx.closePath();
    ctx.fillStyle = type==='speed'?'#ffd166': type==='magnet'?'#7dd3fc': type==='shield'?'#a5b4fc':'#f9a8d4';
    ctx.fill(); ctx.restore();
  }
  function roundRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  function drawCatAstronaut(x,y){
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle = '#f59e0b'; roundRect(-11,-6,22,24,6); ctx.fill();
    ctx.beginPath(); ctx.fillStyle='#fda4af'; ctx.arc(0,-16,11,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.moveTo(-7,-22); ctx.lineTo(-2,-30); ctx.lineTo(3,-22); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(7,-22); ctx.lineTo(2,-30); ctx.lineTo(-3,-22); ctx.closePath(); ctx.fill();
    ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(-3,-17,2,0,Math.PI*2); ctx.arc(3,-17,2,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.strokeStyle='rgba(173,216,230,.85)'; ctx.lineWidth=3; ctx.arc(0,-16,14,0,Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  // ========= –ì–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª =========
  let last = performance.now(), paused = false;
  function loop(now){
    const dt = Math.min(0.033, (now - last)/1000); last = now;
    if (!paused){
      if (state === 'worm'){ updateWorm(dt); tickBoosts(dt); drawWorm(); }
      else if (state === 'cat'){ updateCat(dt); tickBoosts(dt); drawCat(); }
      else {
        const W = canvas.clientWidth, H = canvas.clientHeight;
        ctx.fillStyle='#0a0e19'; ctx.fillRect(0,0,W,H);
        ctx.save(); ctx.globalAlpha=.5;
        for(let i=0;i<100;i++){ const x=(i*73)%W; const y=(i*41)%H; ctx.fillStyle=i%9===0?'#7dd3ff':'#cbd5e1'; ctx.fillRect(x,y,2,2); }
        ctx.restore();
      }
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
  document.addEventListener('visibilitychange', ()=> paused = document.hidden);

  // –°—Ç–∞—Ä—Ç
  showMenu();
})();
</script>
</body>
</html>